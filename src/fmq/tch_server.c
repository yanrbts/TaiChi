/*
 * Project:
 *  ___________      .___________ .__    .__ 
 * \__    ___/____  |__\_   ___ \|  |__ |__|
 *   |    |  \__  \ |  /    \  \/|  |  \|  |
 *   |    |   / __ \|  \     \___|   Y  \  |
 *   |____|  (____  /__|\______  /___|  /__|
 *                \/           \/     \/   
 *
 * Copyright (C) 2021 - 2022, Yan RuiBing, <772166784@qq.com>, et al.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.
 *
 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 * copies of the Software, and permit persons to whom the Software is
 * furnished to do so, under the terms of the COPYING file.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 */
#include <tch_server.h>

//  There's no point making these configurable
#define CHUNK_SIZE      1000000

/* State machine constants */
typedef enum {
    start_state = 1,
    ready_state = 2,
    dispatching_state = 3,
    defaults_state = 4
} state_t;

typedef enum {
    NULL_event = 0,
    terminate_event = 1,
    ohai_event = 2,
    icanhaz_event = 3,
    nom_event = 4,
    dispatch_event = 5,
    hugz_event = 6,
    kthxbai_event = 7,
    send_chunk_event = 8,
    next_patch_event = 9,
    no_credit_event = 10,
    finished_event = 11,
    expired_event = 12
} event_t;

//  Names for state machine logging and error reporting
static char *
s_state_name [] = {
    "(NONE)",
    "start",
    "ready",
    "dispatching",
    "defaults"
};

static char *
s_event_name [] = {
    "(NONE)",
    "terminate",
    "OHAI",
    "ICANHAZ",
    "NOM",
    "dispatch",
    "HUGZ",
    "KTHXBAI",
    "send_chunk",
    "next_patch",
    "no_credit",
    "finished",
    "expired"
};

typedef struct tch_server_s     tch_server_t;
typedef struct tch_s_server_s   tch_s_server_t;
typedef struct tch_svsub_s      tch_svsub_t;
typedef struct tch_svclient_s   tch_svclient_t;
typedef struct tch_mount_s      tch_mount_t;
typedef struct tch_sv_client_s  tch_sv_client_t;

/* This structure defines the context for each running server. Store
 * whatever properties and structures you need for the server. */
struct tch_server_s {
    zsock_t     *pipe;              //  Actor pipe back to caller
    zconfig_t   *config;            //  Current loaded configuration
    zlist_t     *mounts;            //  Mount points
};

/* This structure defines the state for each client connection. It will
 * be passed to each action in the 'self' argument. */
struct tch_svclient_s {
    tch_server_t    *server;        //  Reference to parent server
    fmq_msg_t       *message;       //  Message in and out

    //  Properties not generated by gsl
    uint64_t        credit;         //  Credit remaining
    zlist_t         *patches;       //  Patches to send
    zdir_patch_t    *patch;         //  Current patch
    zfile_t         *file;          //  Current file we're sending
    off_t           offset;         //  Offset of next read in file
    uint64_t        sequence;       //  Sequence number for chunck
};

/* Subscription object */
struct tch_svsub_s {
    tch_svclient_t  *client;        //  Always refers to live client
    char            *path;          //  Path client is subscribed to
    zhash_t         *cache;         //  Client's cache list
};

/* Mount point in memory */
struct tch_mount_s {
    char        *location;         //  Physical location
    char        *alias;            //  Alias into our tree
    zdir_t      *dir;              //  Directory snapshot
    zlist_t     *subs;             //  Client subscriptions
};

/* Context for the whole server task. This embeds the application-level
 * server context at its start (the entire structure, not a reference),
 * so we can cast a pointer between server_t and s_server_t arbitrarily.*/
struct tch_s_server_s {
    tch_server_t    server;            //  Application-level server context
    zsock_t         *pipe;             //  Socket to back to caller API
    zsock_t         *router;           //  Socket to talk to clients
    int             port;              //  Server port bound to
    zloop_t         *loop;             //  Reactor for server sockets
    fmq_msg_t       *message;          //  Message received or sent
    zhash_t         *clients;          //  Clients we're connected to
    zconfig_t       *config;           //  Configuration tree
    uint            client_id;         //  Client identifier counter
    size_t          timeout;           //  Default client expiry timeout
    bool            verbose;           //  Verbose logging enabled?
    char            *log_prefix;       //  Default log prefix
};

/* Context for each connected client. This embeds the application-level
 * client context at its start (the entire structure, not a reference),
 * so we can cast a pointer between client_t and s_client_t arbitrarily.*/
struct tch_sv_client_s{
    tch_svclient_t  client;             //  Application-level client context
    tch_s_server_t  *server;            //  Parent server context
    char            *hashkey;           //  Key into server->clients hash
    zframe_t        *routing_id;        //  Routing_id back to client
    uint            unique_id;          //  Client identifier in server
    state_t         state;              //  Current state
    event_t         event;              //  Current event
    event_t         next_event;         //  The next event
    event_t         exception;          //  Exception event, if any
    int             wakeup;             //  zloop timer for client alarms
    void            *ticket;            //  zloop ticket for client timeouts
    event_t         wakeup_event;       //  Wake up with this event
    char            log_prefix [41];    //  Log prefix string
};

static int server_initialize(tch_server_t *self);
static void server_terminate (tch_server_t *self);
static zmsg_t *server_method (tch_server_t *self, const char *method, zmsg_t *msg);
static int monitor_the_server(zloop_t *loop, int timer_id, void *arg);
static void sub_patch_add(tch_svsub_t *self, zdir_patch_t *patch);
static void sub_destroy (tch_svsub_t **self_p);
static void engine_set_monitor(tch_server_t *server, size_t interval, zloop_timer_fn monitor);
static void engine_broadcast_event(tch_server_t *server, tch_svclient_t *client, event_t event);
static void engine_set_next_event (tch_svclient_t *client, event_t event);
static void engine_set_exception (tch_svclient_t *client, event_t event);
static void engine_set_wakeup_event (tch_svclient_t *client, size_t delay, event_t event);
static void engine_send_event (tch_svclient_t *client, event_t event);
static void engine_handle_socket (tch_server_t *server, void *sock, zloop_reader_fn handler);
static void engine_set_log_prefix (tch_svclient_t *client, const char *string);
static void engine_configure (tch_server_t *server, const char *path, const char *value);
static bool engine_verbose (tch_server_t *server);
static event_t s_protocol_event (fmq_msg_t *message);
static tch_sv_client_t *s_client_new (tch_s_server_t *server, zframe_t *routing_id);
static void s_client_execute(tch_sv_client_t *self, event_t event);
static void s_client_destroy (tch_sv_client_t **self_p);
static void s_client_free (void *argument);
static int s_client_handle_wakeup (zloop_t *loop, int timer_id, void *argument);
static int s_client_handle_ticket (zloop_t *loop, int timer_id, void *argument);
static void store_client_subscription (tch_svclient_t *self);
static void store_client_credit (tch_svclient_t *self);
static tch_mount_t *mount_new (char *location, char *alias);
static bool mount_refresh(tch_mount_t *self, tch_server_t *server);
static void mount_sub_store (tch_mount_t *self, tch_svclient_t *client, fmq_msg_t *request);
static void mount_sub_purge (tch_mount_t *self, tch_svclient_t *client);
static void mount_destroy (tch_mount_t **self_p);
static void check_for_client_data (tch_svclient_t *self);
static int client_initialize (tch_svclient_t *self);
static void client_terminate (tch_svclient_t *self);
static void handle_client_no_credit (tch_svclient_t *self);
static void handle_client_finished (tch_svclient_t *self);
static void s_server_config_global (tch_s_server_t *self);
static void s_server_destroy (tch_s_server_t **self_p);
static void s_server_config_service (tch_s_server_t *self);
static int s_server_handle_pipe (zloop_t *loop, zsock_t *reader, void *argument);
static int s_server_handle_protocol (zloop_t *loop, zsock_t *reader, void *argument);
static int s_watch_server_config (zloop_t *loop, int timer_id, void *argument);
static void s_satisfy_pedantic_compilers (void);
static void get_next_patch_for_client (tch_svclient_t *self);
static tch_svsub_t *sub_new(tch_svclient_t *client, const char *path, zhash_t *cache);


/* Allocate properties and structures for a new server instance.
 * Return 0 if OK, or -1 if there was an error. */
static int 
server_initialize (tch_server_t *self)
{
    //  Construct properties here
    // zsys_notice("starting filemq service");
    self->mounts = zlist_new();
    /* Register with the engine a function that will be called
     * every second by the engine.*/
    engine_set_monitor (self, 1000, monitor_the_server);
    return 0;
}

/* Register monitor function that will be called at regular intervals
 * by the server engine */
static void
engine_set_monitor (tch_server_t *server, size_t interval, zloop_timer_fn monitor)
{
    if (server) {
        tch_s_server_t *self = (tch_s_server_t *)server;
        int rc = zloop_timer(self->loop, interval, 0, monitor, self);
        assert(rc >= 0);
    }
}

/* Monitor the servers published directories for changes */
static int
monitor_the_server (zloop_t *loop, int timer_id, void *arg)
{
    tch_server_t *self = (tch_server_t *)arg;
    bool activity = false;
    tch_mount_t *mount = (tch_mount_t *)zlist_first(self->mounts);
    while (mount) {
        if (mount_refresh(mount, self))
            activity = true;
        mount = (tch_mount_t *) zlist_next (self->mounts);
    }
    if (activity)
        engine_broadcast_event (self, NULL, dispatch_event);

    return 0;
}

/* Reloads directory tree and returns true if activity, false if the same */
static bool
mount_refresh (tch_mount_t *self, tch_server_t *server)
{
    //zsys_debug("mount_refresh: checking for changes to mount point");
    bool activity = false;

    //  Get latest snapshot and build a patches list for any changes
    //  Load the server local path, no parent dir.
    zdir_t *latest = zdir_new(self->location, NULL);
    //zsys_debug("mount_refresh: old dir");
    //zdir_print(self->dir, 2);
    //zsys_debug("mount_refresh: new dir");
    //zdir_print(latest, 2);
    
    //  Get list of patches using old and new dir with location as seen by
    //  the client.
    zlist_t *patches = zdir_diff(self->dir, latest, self->alias);

    //  Go through the patches just received and print information about them
    zdir_patch_t *tmppatch = (zdir_patch_t *)zlist_first(patches);
    while (tmppatch) {
        //zsys_debug("--- patch=%s, vpath=%s, op=%d", zdir_patch_path(tmppatch),
        //    zdir_patch_vpath(tmppatch), zdir_patch_op(tmppatch));
        //zfile_t *tmpfile = zdir_patch_file(tmppatch);
        //zsys_debug("----- file name=%s", zfile_filename(tmpfile, NULL));
        tmppatch = (zdir_patch_t *)zlist_next(patches);
    }

    //  Drop old directory and replace with latest version
    zdir_destroy(&self->dir);
    self->dir = latest;

    //  Copy new patches to clients' patches list
    tch_svsub_t *sub = (tch_svsub_t *)zlist_first(self->subs);
    while (sub) {
        zdir_patch_t *patch = (zdir_patch_t *)zlist_first(patches);
        while (patch) {
            sub_patch_add(sub, patch);
            patch = (zdir_patch_t *)zlist_next(patches);
            activity = true;
        }
        sub = (tch_svsub_t *)zlist_next(self->subs);
    }

    //  Destroy patches, they've all been copied
    while (zlist_size(patches)) {
        zdir_patch_t *patch = (zdir_patch_t *)zlist_pop(patches);
        zdir_patch_destroy(&patch);
    }
    zlist_destroy(&patches);
    return activity;
}

/* Add patch to sub client patches list */
static void
sub_patch_add (tch_svsub_t *self, zdir_patch_t *patch)
{
    //  Debug print where we are and information on the incoming patch
    //zsys_debug("@@ sub_patch_add, incoming patch info below");
    //zsys_debug("path=%s, op=%d, vpath=%s", zdir_patch_path (patch), zdir_patch_op (patch), zdir_patch_vpath (patch));

    //  Skip file creation if client already has identical file
    //  Populate the digest for the associated patch
    zdir_patch_digest_set(patch);
    if (zdir_patch_op(patch) == patch_create) {
        char *digest = (char *)zhash_lookup(self->cache,
                        zdir_patch_vpath(patch) + strlen(self->path) + 1);
        if (digest && streq(digest, zdir_patch_digest(patch))) {
            //zsys_debug ("sub_patch_add: skipping patch");
            return;             //  Just skip patch for this client
        }
    }

    //  Remove any previous patches for the same file
    zdir_patch_t *existing = (zdir_patch_t *)zlist_first(self->client->patches);
    while (existing) {
        if (streq (zdir_patch_vpath (patch), zdir_patch_vpath (existing))) {
            //zsys_debug ("!!! removing patch !!!");
            //zsys_debug ("path=%s, op=%d, vpath=%s", zdir_patch_path (existing),
            //    zdir_patch_op (existing), zdir_patch_vpath (existing));
            zlist_remove (self->client->patches, existing);
            zdir_patch_destroy (&existing);
            break;
        }
        existing = (zdir_patch_t *) zlist_next (self->client->patches);
    }
    if (zdir_patch_op (patch) == patch_create) {
        //zsys_debug ("---> inserting patch <---");
        //zsys_debug ("path=%s, op=%d, vpath=%s", zdir_patch_path (patch),
        //    zdir_patch_op (patch), zdir_patch_vpath (patch));
        zhash_insert (self->cache,
            zdir_patch_digest (patch), (void *) zdir_patch_vpath (patch));
    }
    //zsys_debug ("+++ adding following patch to client list +++");
    //zsys_debug ("path=%s, op=%d, vpath=%s", zdir_patch_path (patch),
    //    zdir_patch_op (patch), zdir_patch_vpath (patch));

    //  Track that we've queued patch for client, so we don't do it twice
    zdir_patch_t *patch_add = zdir_patch_dup (patch);
    if (patch_add) {
        int rc = zlist_append (self->client->patches, (void *) patch_add);
        if (rc != 0)
            zsys_error ("unable to append new patch +++");
    } else {
        zsys_error ("unable to duplicate patch");
    }
}

//  Execute 'event' on all clients known to the server. If you pass a
//  client argument, that client will not receive the broadcast. If you
//  want to pass any arguments, store them in the server context.
static void
engine_broadcast_event (tch_server_t *server, tch_svclient_t *client, event_t event)
{
    if (server) {
        tch_s_server_t *self = (tch_s_server_t *)server;
        zlist_t *keys = zhash_keys(self->clients);
        char *key = (char *)zlist_first(keys);
        while (key) {
            tch_sv_client_t *target = (tch_sv_client_t *)zhash_lookup(self->clients, key);
            if (target != (tch_sv_client_t *)client)
                s_client_execute (target, event);
            key = (char *)zlist_next (keys);
        }
        zlist_destroy(&keys);
    }
}

//  Raise an exception with 'event', halting any actions in progress.
//  Continues execution of actions defined for the exception event.
static void
engine_set_exception (tch_svclient_t *client, event_t event)
{
    if (client) {
        tch_sv_client_t *self = (tch_sv_client_t *) client;
        self->exception = event;
    }
}

//  Set wakeup alarm after 'delay' msecs. The next state should
//  handle the wakeup event. The alarm is cancelled on any other
//  event.
static void
engine_set_wakeup_event (tch_svclient_t *client, size_t delay, event_t event)
{
    if (client) {
        tch_sv_client_t *self = (tch_sv_client_t *) client;
        if (self->wakeup) {
            zloop_timer_end (self->server->loop, self->wakeup);
            self->wakeup = 0;
        }
        self->wakeup = zloop_timer (
            self->server->loop, delay, 1, s_client_handle_wakeup, self);
        self->wakeup_event = event;
    }
}

//  Execute 'event' on specified client. Use this to send events to
//  other clients. Cancels any wakeup alarm on that client.
static void
engine_send_event (tch_svclient_t *client, event_t event)
{
    if (client) {
        tch_sv_client_t *self = (tch_sv_client_t *) client;
        s_client_execute (self, event);
    }
}

//  Poll actor or zsock for activity, invoke handler on any received
//  message. Handler must be a CZMQ zloop_fn function; receives server
//  as arg.
static void
engine_handle_socket (tch_server_t *server, void *sock, zloop_reader_fn handler)
{
    if (server) {
        tch_s_server_t *self = (tch_s_server_t *) server;
        //  Resolve zactor_t -> zsock_t
        if (zactor_is (sock))
            sock = zactor_sock ((zactor_t *) sock);
        else
            assert (zsock_is (sock));
        if (handler != NULL) {
            int rc = zloop_reader (self->loop, (zsock_t *) sock, handler, self);
            assert (rc == 0);
            zloop_reader_set_tolerant (self->loop, (zsock_t *) sock);
        }
        else
            zloop_reader_end (self->loop, (zsock_t *) sock);
    }
}

//  Set log file prefix; this string will be added to log data, to make
//  log data more searchable. The string is truncated to ~20 chars.
static void
engine_set_log_prefix (tch_svclient_t *client, const char *string)
{
    if (client) {
        tch_sv_client_t *self = (tch_sv_client_t *) client;
        snprintf (self->log_prefix, sizeof (self->log_prefix),
            "%6d:%-33s", self->unique_id, string);
    }
}

//  Set a configuration value in the server's configuration tree. The
//  properties this engine uses are: server/verbose, server/timeout, and
//  server/background. You can also configure other abitrary properties.
static void
engine_configure (tch_server_t *server, const char *path, const char *value)
{
    if (server) {
        tch_s_server_t *self = (tch_s_server_t *) server;
        zconfig_put (self->config, path, value);
    }
}

//  Return true if server is running in verbose mode, else return false.
static bool
engine_verbose (tch_server_t *server)
{
    if (server) {
        tch_s_server_t *self = (tch_s_server_t *) server;
        return self->verbose;
    }
    return false;
}


//  Generic methods on protocol messages
//  TODO: replace with lookup table, since ID is one byte
static event_t
s_protocol_event (fmq_msg_t *message)
{
    assert (message);
    switch (fmq_msg_id (message)) {
        case FMQ_MSG_OHAI:
            return ohai_event;
            break;
        case FMQ_MSG_ICANHAZ:
            return icanhaz_event;
            break;
        case FMQ_MSG_NOM:
            return nom_event;
            break;
        case FMQ_MSG_HUGZ:
            return hugz_event;
            break;
        case FMQ_MSG_KTHXBAI:
            return kthxbai_event;
            break;
        default:
            //  Invalid fmq_msg_t
            return terminate_event;
    }
}

//  Client methods

static tch_sv_client_t *
s_client_new (tch_s_server_t *server, zframe_t *routing_id)
{
    tch_sv_client_t *self = (tch_sv_client_t *) zmalloc (sizeof (tch_sv_client_t));
    assert (self);
    assert ((tch_sv_client_t *) &self->client == self);

    self->server = server;
    self->hashkey = zframe_strhex (routing_id);
    self->routing_id = zframe_dup (routing_id);
    self->unique_id = server->client_id++;
    engine_set_log_prefix (&self->client, server->log_prefix);

    self->client.server = (tch_server_t *) server;
    self->client.message = server->message;

    //  If expiry timers are being used, create client ticket
    if (server->timeout)
        self->ticket = zloop_ticket (server->loop, s_client_handle_ticket, self);
    //  Give application chance to initialize and set next event
    self->state = start_state;
    self->event = NULL_event;
    client_initialize (&self->client);
    return self;
}

static void
s_client_destroy (tch_sv_client_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        tch_sv_client_t *self = *self_p;
        if (self->wakeup)
            zloop_timer_end (self->server->loop, self->wakeup);
        if (self->ticket)
            zloop_ticket_delete (self->server->loop, self->ticket);
        zframe_destroy (&self->routing_id);
        //  Provide visual clue if application misuses client reference
        engine_set_log_prefix (&self->client, "*** TERMINATED ***");
        client_terminate (&self->client);
        free (self->hashkey);
        free (self);
        *self_p = NULL;
    }
}

//  Callback when we remove client from 'clients' hash table
static void
s_client_free (void *argument)
{
    tch_sv_client_t *client = (tch_sv_client_t *) argument;
    s_client_destroy (&client);
}

/* Execute state machine as long as we have events */
static void
s_client_execute (tch_sv_client_t *self, event_t event)
{
    self->next_event = event;
    //  Cancel wakeup timer, if any was pending
    if (self->wakeup) {
        zloop_timer_end(self->server->loop, self->wakeup);
        self->wakeup = 0;
    }

    while (self->next_event > 0) {
        self->event = self->next_event;
        self->next_event = NULL_event;
        self->exception = NULL_event;

        if (self->server->verbose) {
            zsys_debug ("%s: %s:", self->log_prefix, s_state_name [self->state]);
            zsys_debug ("%s:     %s", self->log_prefix, s_event_name [self->event]);
        }

        switch (self->state) {
        case start_state:
            if (self->event == ohai_event) {
                if (!self->exception) {
                    //  send OHAI_OK
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send OHAI_OK", self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_OHAI_OK);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception)
                    self->state = ready_state;
            } else if (self->event == expired_event) {
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            } else {
                //  Handle unexpected protocol events
                if (!self->exception) {
                    //  send RTFM
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send RTFM", self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_RTFM);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            }
            break;
        case ready_state:
            if (self->event == icanhaz_event) {
                if (!self->exception) {
                    //  store client subscription
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ store client subscription", self->log_prefix);
                    store_client_subscription (&self->client);
                }
                if (!self->exception) {
                    //  send ICANHAZ_OK
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send ICANHAZ_OK", self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_ICANHAZ_OK);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception) {
                    //  check for client data
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ check for client data", self->log_prefix);
                    check_for_client_data (&self->client);
                }
                if (!self->exception)
                    self->state = dispatching_state;
            } else if (self->event == nom_event) {
                if (!self->exception) {
                    //  store client credit
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ store client credit", self->log_prefix);
                    store_client_credit (&self->client);
                }
                if (!self->exception) {
                    //  check for client data
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ check for client data", self->log_prefix);
                    check_for_client_data (&self->client);
                }
                if (!self->exception)
                    self->state = dispatching_state;
            } else if (self->event == dispatch_event) {
                if (!self->exception) {
                    //  check for client data
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ check for client data", self->log_prefix);
                    check_for_client_data (&self->client);
                }
                if (!self->exception)
                    self->state = dispatching_state;
            } else if (self->event == hugz_event) {
                if (!self->exception) {
                    //  send HUGZ_OK
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send HUGZ_OK",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_HUGZ_OK);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
            } else if (self->event == kthxbai_event) {
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            } else if (self->event == ohai_event) {
                if (!self->exception) {
                    //  send OHAI_OK
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send OHAI_OK",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_OHAI_OK);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
            } else if (self->event == expired_event) {
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            } else {
                //  Handle unexpected protocol events
                if (!self->exception) {
                    //  send RTFM
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send RTFM",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_RTFM);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            }
            break;
        case dispatching_state:
            if (self->event == send_chunk_event) {
                if (!self->exception) {
                    //  get next patch for client
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ get next patch for client", self->log_prefix);
                    get_next_patch_for_client (&self->client);
                }
                if (!self->exception) {
                    //  send CHEEZBURGER
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send CHEEZBURGER",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_CHEEZBURGER);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception) {
                    //  check for client data
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ check for client data", self->log_prefix);
                    check_for_client_data (&self->client);
                }
            } else if (self->event == next_patch_event) {
                if (!self->exception) {
                    //  get next patch for client
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ get next patch for client", self->log_prefix);
                    get_next_patch_for_client (&self->client);
                }
                if (!self->exception) {
                    //  send CHEEZBURGER
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send CHEEZBURGER",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_CHEEZBURGER);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception) {
                    //  check for client data
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ check for client data", self->log_prefix);
                    check_for_client_data (&self->client);
                }
            } else if (self->event == no_credit_event) {
                if (!self->exception) {
                    //  handle client no credit
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ handle client no credit", self->log_prefix);
                    handle_client_no_credit (&self->client);
                }
                if (!self->exception)
                    self->state = ready_state;
            } else if (self->event == finished_event) {
                if (!self->exception) {
                    //  handle client finished
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ handle client finished", self->log_prefix);
                    handle_client_finished (&self->client);
                }
                if (!self->exception)
                    self->state = ready_state;
            } else if (self->event == nom_event) {
                if (!self->exception) {
                    //  store client credit
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ store client credit", self->log_prefix);
                    store_client_credit (&self->client);
                }
                if (!self->exception) {
                    //  check for client data
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ check for client data", self->log_prefix);
                    check_for_client_data (&self->client);
                }
            } else if (self->event == hugz_event) {
                if (!self->exception) {
                    //  send HUGZ_OK
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send HUGZ_OK", self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_HUGZ_OK);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
            } else if (self->event == kthxbai_event) {
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            } else if (self->event == ohai_event) {
                if (!self->exception) {
                    //  send OHAI_OK
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send OHAI_OK",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_OHAI_OK);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception)
                    self->state = ready_state;
            } else if (self->event == expired_event) {
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            } else {
                //  Handle unexpected protocol events
                if (!self->exception) {
                    //  send RTFM
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send RTFM",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_RTFM);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            }
            break;
        case defaults_state:
            if (self->event == expired_event) {
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            }
            {
                //  Handle unexpected protocol events
                if (!self->exception) {
                    //  send RTFM
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ send RTFM",
                            self->log_prefix);
                    fmq_msg_set_id (self->server->message, FMQ_MSG_RTFM);
                    fmq_msg_set_routing_id (self->server->message, self->routing_id);
                    fmq_msg_send (self->server->message, self->server->router);
                }
                if (!self->exception) {
                    //  terminate
                    if (self->server->verbose)
                        zsys_debug ("%s:         $ terminate", self->log_prefix);
                    self->next_event = terminate_event;
                }
            }
            break;
        }

        //  If we had an exception event, interrupt normal programming
        if (self->exception) {
            if (self->server->verbose)
                zsys_debug ("%s:         ! %s", self->log_prefix, s_event_name [self->exception]);
            self->next_event = self->exception;
        }

        if (self->next_event == terminate_event) {
            //  Automatically calls s_client_destroy
            zhash_delete (self->server->clients, self->hashkey);
            break;
        } else if (self->server->verbose) {
            zsys_debug ("%s:         > %s", self->log_prefix, s_state_name [self->state]);
        }
    }
}

/* store_client_subscription */
static void
store_client_subscription (tch_svclient_t *self)
{
    //  Find mount point with longest match to subscription
    const char *path = fmq_msg_path (self->message);

    tch_mount_t *check = (tch_mount_t *)zlist_first(self->server->mounts);
    tch_mount_t *mount = check;
    while (check) {
        //  If check->alias is prefix of path and alias is
        //  longer than current mount then we have a new mount
        //zsys_debug ("path=%s, check->alias=%s, mount->alias=%s",
        //    path, check->alias, mount->alias);
        if (strncmp (path, check->alias, strlen (check->alias)) == 0
        &&  strlen (check->alias) > strlen (mount->alias)) {
            //zsys_debug ("prefix match, alias is longer");
            mount = check;
        }
        check = (tch_mount_t *) zlist_next (self->server->mounts);
    }
    //  If subscription matches nothing, discard it
    if (mount) {
        //zsys_debug ("new subscription being stored");
        mount_sub_store (mount, self, self->message);
    }
}

/* Store subscription for mount point */
static void
mount_sub_store (tch_mount_t *self, tch_svclient_t *client, fmq_msg_t *request)
{
    assert(self);
    assert(self->subs);

    //  Store subscription along with any previous ones
    //  Coalesce subscriptions that are on same path
    const char *path = fmq_msg_path(request);
    tch_svsub_t *sub = (tch_svsub_t *)zlist_first(self->subs);
    while (sub) {
        if (client == sub->client) {
            //  If old subscription is superset/same as new, ignore new
            if (strncmp (path, sub->path, strlen (sub->path)) == 0) {
                zsys_debug ("new subscription already exists");
                return;
            } else if (strncmp (sub->path, path, strlen (path)) == 0) {
                //  If new subscription is superset of old one, remove old
                zsys_debug ("superset, sub->path=%s, path=%s", sub->path, path);
                zlist_remove (self->subs, sub);
                sub_destroy (&sub);
                sub = (tch_svsub_t *) zlist_first (self->subs);
            } else {
                sub = (tch_svsub_t *) zlist_next (self->subs);
            }
        } else {
            sub = (tch_svsub_t *) zlist_next (self->subs);
        }
    }
    //  New subscription for this client, append to our list
    sub = sub_new(client, path, fmq_msg_cache (request));
    zlist_append(self->subs, sub);
}

/* Destructor for the sub (a.k.a subscription) class */
static void
sub_destroy (tch_svsub_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        tch_svsub_t *self = *self_p;
        zhash_destroy (&self->cache);
        free (self->path);
        free (self);
        *self_p = NULL;
    }
}

/* check_for_client_data */
static void
check_for_client_data (tch_svclient_t *self)
{
    if (!self->credit) {
        //zsys_debug ("^^^ client has no credit, no credit event ^^^");
        engine_set_next_event (self, no_credit_event);
        return;
    }

    if (zlist_size (self->patches) == 0 && self->patch == NULL) {
        //zsys_debug ("^^^ client has no patches, finished event ^^^");
        engine_set_next_event (self, finished_event);
    } else {
        //zsys_debug ("^^^ client has patches, send chunk event ^^^");
        engine_set_next_event (self, send_chunk_event);
    }
}

/* Set the next event, needed in at least one action in an internal
 * state; otherwise the state machine will wait for a message on the
 * router socket and treat that as the event. */
static void
engine_set_next_event (tch_svclient_t *client, event_t event)
{
    if (client) {
        tch_sv_client_t *self = (tch_sv_client_t *) client;
        self->next_event = event;
    }
}

/* store_client_credit */
static void
store_client_credit (tch_svclient_t *self)
{
    self->credit += fmq_msg_credit (self->message);
}

/* get_next_patch_for_client */
static void
get_next_patch_for_client (tch_svclient_t *self)
{
    //zsys_debug ("@@ get_next_patch_for_client");
    //  Get next patch for client if we're not doing one already
    if (self->patch == NULL) {
        self->patch = (zdir_patch_t *) zlist_pop (self->patches);
        if (self->patch) {
            //zsys_debug ("~~~ just popped following patch ~~~");
            //zsys_debug ("~~~~ path=%s, op=%d, vpath=%s",
            //    zdir_patch_path (self->patch), zdir_patch_op (self->patch),
            //    zdir_patch_vpath (self->patch));
        }
    } else {
        //zsys_debug ("~~~ current patch ~~~");
        //zsys_debug ("~~~~ path=%s, op=%d, vpath=%s",
        //    zdir_patch_path (self->patch), zdir_patch_op (self->patch),
        //    zdir_patch_vpath (self->patch));
    }
    if (self->patch == NULL) {
        //zsys_debug ("~~~ no patch ~~~");
        engine_set_next_event (self, finished_event);
        return;
    }

    //  Get virtual path from patch
    fmq_msg_set_filename (self->message, zdir_patch_vpath (self->patch));

    //  We can process a delete patch right away
    if (zdir_patch_op (self->patch) == patch_delete) {
        //zsys_debug ("~~~ current patch is delete ~~~");
        fmq_msg_set_sequence (self->message, self->sequence++);
        fmq_msg_set_operation (self->message, FMQ_MSG_FILE_DELETE);
        fmq_msg_set_eof (self->message, 0);

        //  No reliability in this version, assume patch delivered safely
        zdir_patch_destroy (&self->patch);
    } else if (zdir_patch_op (self->patch) == patch_create) {
        //zsys_debug ("~~~ current patch is create ~~~");
        //  Create patch refers to file, open that for input if needed
        if (self->file == NULL) {
            //zsys_debug ("~~~ client's file is NULL ~~~");
            self->file = zfile_dup (zdir_patch_file (self->patch));
            if (zfile_input (self->file)) {
                //  File no longer available, skip it
                //zsys_debug ("~~~ file no longer available ~~~");
                zdir_patch_destroy (&self->patch);
                zfile_destroy (&self->file);
                engine_set_next_event (self, next_patch_event);
                return;
            }
            self->offset = 0;
        }
        //  Get next chunk for file
        //zsys_debug ("~~~ read chunk from file ~~~");
        zchunk_t *chunk = zfile_read (self->file, CHUNK_SIZE, self->offset);
        assert (chunk);

        //  Check if we have the credit to send chunk
        if (zchunk_size (chunk) <= self->credit) {
            //zsys_debug ("~~~ have credit, prepare to send ~~~");
            fmq_msg_set_sequence (self->message, self->sequence++);
            fmq_msg_set_operation (self->message, FMQ_MSG_FILE_CREATE);
            fmq_msg_set_offset (self->message, self->offset);
            fmq_msg_set_eof (self->message, 0);

            self->offset += zchunk_size (chunk);
            self->credit -= zchunk_size (chunk);

            //  Zero-sized chunk means end of file
            if (zchunk_size (chunk) == 0) {
                //zsys_debug ("~~~ chunk is empty ~~~");
                fmq_msg_set_eof (self->message, 1);
                zfile_destroy (&self->file);
                zdir_patch_destroy (&self->patch);
            }
            fmq_msg_set_chunk (self->message, &chunk);
        } else {
            //zsys_debug ("~~~ no credit ~~~");
            zchunk_destroy (&chunk);
            engine_set_next_event (self, no_credit_event);
        }
    }
}

/* handle_client_no_credit */
static void
handle_client_no_credit (tch_svclient_t *self)
{
    //zsys_debug ("!!! client has no credit, moving to ready state !!!");
}

/* handle_client_finished */
static void
handle_client_finished (tch_svclient_t *self)
{
    //zsys_debug ("!!! client has no patches, moving to ready state !!!");
}

/* Free properties and structures for a server instance */
static void
server_terminate (tch_server_t *self)
{
    //  Destroy properties here
    zsys_notice ("terminating filemq service");
    while (zlist_size (self->mounts)) {
        tch_mount_t *mount = (tch_mount_t *) zlist_pop (self->mounts);
        mount_destroy (&mount);
    }
    zlist_destroy (&self->mounts);
}

/* Process server API method, return reply message if any */
static zmsg_t *
server_method (tch_server_t *self, const char *method, zmsg_t *msg)
{
    if (streq (method, "PUBLISH")) {
        char *location = zmsg_popstr (msg);
        char *alias = zmsg_popstr (msg);
        tch_mount_t *mount = mount_new (location, alias);
        zmsg_t *ret_msg = zmsg_new ();
        if (mount) {
            zlist_append (self->mounts, mount);
            zmsg_addstr (ret_msg, "SUCCESS");
        }
        else
            zmsg_addstr (ret_msg, "FAILURE");
        free (location);
        free (alias);
        return ret_msg;
    }

    return NULL;
}

/* Constructor for the mount class
 * Loads directory tree if possible */
static tch_mount_t *
mount_new (char *location, char *alias)
{
    //  Mount path must start with '/'
    //  We'll do better error handling later
    assert (*alias == '/');

    tch_mount_t *self = (tch_mount_t *) zmalloc (sizeof (tch_mount_t));
    self->location = strdup (location);
    self->alias = strdup (alias);
    self->dir = zdir_new (self->location, NULL);
    self->subs = zlist_new ();
    return self;
}

//  Allocate properties and structures for a new client connection and
//  optionally engine_set_next_event (). Return 0 if OK, or -1 on error.
static int
client_initialize (tch_svclient_t *self)
{
    //  Construct properties here
    self->patches = zlist_new ();
    return 0;
}

//  Free properties and structures for a client connection
static void
client_terminate (tch_svclient_t *self)
{
    //  Destroy properties here
    tch_mount_t *mount = (tch_mount_t *) zlist_first (self->server->mounts);
    while (mount) {
        mount_sub_purge (mount, self);
        mount = (tch_mount_t *) zlist_next (self->server->mounts);
    }
    while (zlist_size (self->patches)) {
        zdir_patch_t *patch = (zdir_patch_t *) zlist_pop (self->patches);
        zdir_patch_destroy (&patch);
    }
    zlist_destroy (&self->patches);
    zdir_patch_destroy (&self->patch);
    zfile_destroy (&self->file);
}

//  zloop callback when client wakeup timer expires
static int
s_client_handle_wakeup (zloop_t *loop, int timer_id, void *argument)
{
    tch_sv_client_t *self = (tch_sv_client_t *) argument;
    s_client_execute (self, self->wakeup_event);
    return 0;
}

//  zloop callback when client ticket expires
static int
s_client_handle_ticket (zloop_t *loop, int timer_id, void *argument)
{
    tch_sv_client_t *self = (tch_sv_client_t *) argument;
    self->ticket = NULL;        //  Ticket is now dead
    s_client_execute (self, expired_event);
    return 0;
}

//  Purge subscriptions for a specified client
static void
mount_sub_purge (tch_mount_t *self, tch_svclient_t *client)
{
    tch_svsub_t *sub = (tch_svsub_t *) zlist_first (self->subs);
    while (sub) {
        if (sub->client == client) {
            tch_svsub_t *next = (tch_svsub_t *) zlist_next (self->subs);
            zlist_remove (self->subs, sub);
            sub_destroy (&sub);
            sub = next;
        }
        else
            sub = (tch_svsub_t *) zlist_next (self->subs);
    }
}

//  Destructor for the mount class
static void
mount_destroy (tch_mount_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        tch_mount_t *self = *self_p;
        free (self->location);
        free (self->alias);
        //  Destroy subscriptions
        while (zlist_size (self->subs)) {
            tch_svsub_t *sub = (tch_svsub_t *) zlist_pop (self->subs);
            sub_destroy (&sub);
        }
        zlist_destroy (&self->subs);
        zdir_destroy (&self->dir);
        free (self);
        *self_p = NULL;
    }
}

static void
s_server_config_global (tch_s_server_t *self)
{
    //  Built-in server configuration options
    //
    //  If we didn't already set verbose, check if the config tree wants it
    if (!self->verbose && atoi (zconfig_resolve (self->config, "server/verbose", "0")))
        self->verbose = true;

    //  Default client timeout is 60 seconds
    self->timeout = atoi (zconfig_resolve (self->config, "server/timeout", "60000"));
    zloop_set_ticket_delay (self->loop, self->timeout);

    //  Do we want to run server in the background?
    int background = atoi (zconfig_resolve (self->config, "server/background", "0"));
    if (!background)
        zsys_set_logstream (stdout);
}

static tch_s_server_t *
s_server_new (zsock_t *pipe)
{
    tch_s_server_t *self = (tch_s_server_t *) zmalloc (sizeof (tch_s_server_t));
    assert (self);
    assert ((tch_s_server_t *) &self->server == self);

    self->pipe = pipe;
    self->router = zsock_new (ZMQ_ROUTER);
    assert (self->router);
    //  By default the socket will discard outgoing messages above the
    //  HWM of 1,000. This isn't helpful for high-volume streaming. We
    //  will use a unbounded queue here. If applications need to guard
    //  against queue overflow, they should use a credit-based flow
    //  control scheme.
    zsock_set_unbounded (self->router);
    self->message = fmq_msg_new ();
    self->clients = zhash_new ();
    self->config = zconfig_new ("root", NULL);
    self->loop = zloop_new ();
    srandom ((unsigned int) zclock_time ());
    self->client_id = randof (1000);
    s_server_config_global (self);

    //  Initialize application server context
    self->server.pipe = self->pipe;
    self->server.config = self->config;
    server_initialize (&self->server);

    s_satisfy_pedantic_compilers ();
    return self;
}

static void
s_server_destroy (tch_s_server_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        tch_s_server_t *self = *self_p;
        fmq_msg_destroy (&self->message);
        //  Destroy clients before destroying the server
        zhash_destroy (&self->clients);
        server_terminate (&self->server);
        zsock_destroy (&self->router);
        zconfig_destroy (&self->config);
        zloop_destroy (&self->loop);
        free (self);
        *self_p = NULL;
    }
}

//  Apply service-specific configuration tree:
//   * apply server configuration
//   * print any echo items in top-level sections
//   * apply sections that match methods
static void
s_server_config_service (tch_s_server_t *self)
{
    //  Apply echo commands and class methods
    zconfig_t *section = zconfig_locate (self->config, "fmq_server");
    if (section)
        section = zconfig_child (section);

    while (section) {
        if (streq (zconfig_name (section), "echo"))
            zsys_notice ("%s", zconfig_value (section));
        else
        if (streq (zconfig_name (section), "bind")) {
            char *endpoint = zconfig_resolve (section, "endpoint", "?");
            if (zsock_bind (self->router, "%s", endpoint) == -1)
                zsys_warning ("could not bind to %s (%s)", endpoint, zmq_strerror (zmq_errno ()));
        }
#if (ZMQ_VERSION_MAJOR >= 4)
        else
        if (streq (zconfig_name (section), "security")) {
            char *mechanism = zconfig_resolve (section, "mechanism", "null");
            char *domain = zconfig_resolve (section, "domain", NULL);
            if (streq (mechanism, "null")) {
                zsys_notice ("server is using NULL security");
                if (domain)
                    zsock_set_zap_domain (self->router, NULL);
            }
            else
            if (streq (mechanism, "plain")) {
                zsys_notice ("server is using PLAIN security");
                zsock_set_plain_server (self->router, 1);
            }
            else
                zsys_warning ("mechanism=%s is not supported", mechanism);
        }
#endif
        section = zconfig_next (section);
    }
    s_server_config_global (self);
}

//  Process message from pipe
static int
s_server_handle_pipe (zloop_t *loop, zsock_t *reader, void *argument)
{
    tch_s_server_t *self = (tch_s_server_t *) argument;
    zmsg_t *msg = zmsg_recv (self->pipe);
    if (!msg)
        return -1;              //  Interrupted; exit zloop
    char *method = zmsg_popstr (msg);
    if (self->verbose)
        zsys_debug ("%s:     API command=%s", self->log_prefix, method);

    if (streq (method, "VERBOSE"))
        self->verbose = true;
    else
    if (streq (method, "$TERM")) {
        //  Shutdown the engine
        free (method);
        zmsg_destroy (&msg);
        return -1;
    }
    else
    if (streq (method, "BIND")) {
        //  Bind to a specified endpoint, which may use an ephemeral port
        char *endpoint = zmsg_popstr (msg);
        self->port = zsock_bind (self->router, "%s", endpoint);
        if (self->port == -1)
            zsys_warning ("could not bind to %s", endpoint);
        free (endpoint);
    }
    else
    if (streq (method, "PORT")) {
        //  Return PORT + port number from the last bind, if any
        zstr_sendm (self->pipe, "PORT");
        zstr_sendf (self->pipe, "%d", self->port);
    }
    else                       //  Deprecated method name
    if (streq (method, "LOAD") || streq (method, "CONFIGURE")) {
        char *filename = zmsg_popstr (msg);
        zconfig_destroy (&self->config);
        self->config = zconfig_load (filename);
        if (self->config) {
            s_server_config_service (self);
            self->server.config = self->config;
        }
        else {
            zsys_warning ("cannot load config file '%s'", filename);
            self->config = zconfig_new ("root", NULL);
        }
        free (filename);
    }
    else
    if (streq (method, "SET")) {
        char *path = zmsg_popstr (msg);
        char *value = zmsg_popstr (msg);
        zconfig_put (self->config, path, value);
        if (streq (path, "server/animate")) {
            zsys_warning ("'%s' is deprecated, use VERBOSE command instead", path);
            self->verbose = (atoi (value) == 1);
        }
        s_server_config_global (self);
        free (path);
        free (value);
    }
    else
    if (streq (method, "SAVE")) {
        char *filename = zmsg_popstr (msg);
        if (zconfig_save (self->config, filename))
            zsys_warning ("cannot save config file '%s'", filename);
        free (filename);
    }
    else {
        //  Execute custom method
        zmsg_t *reply = server_method (&self->server, method, msg);
        //  If reply isn't null, send it to caller
        zmsg_send (&reply, self->pipe);
    }
    free (method);
    zmsg_destroy (&msg);
    return 0;
}

//  Handle a protocol message from the client
static int
s_server_handle_protocol (zloop_t *loop, zsock_t *reader, void *argument)
{
    tch_s_server_t *self = (tch_s_server_t *) argument;
    //  We process as many messages as we can, to reduce the overhead
    //  of polling and the reactor:
    while (zsock_events (self->router) & ZMQ_POLLIN) {
        if (fmq_msg_recv (self->message, self->router))
            return -1;      //  Interrupted; exit zloop

        //  TODO: use binary hashing on routing_id
        char *hashkey = zframe_strhex (fmq_msg_routing_id (self->message));
        tch_sv_client_t *client = (tch_sv_client_t *) zhash_lookup (self->clients, hashkey);
        if (client == NULL) {
            client = s_client_new (self, fmq_msg_routing_id (self->message));
            zhash_insert (self->clients, hashkey, client);
            zhash_freefn (self->clients, hashkey, s_client_free);
        }
        free (hashkey);
        //  Any input from client counts as activity
        if (client->ticket)
            zloop_ticket_reset (self->loop, client->ticket);

        //  Pass to client state machine
        s_client_execute (client, s_protocol_event (self->message));
    }
    return 0;
}

//  Watch server config file and reload if changed
static int
s_watch_server_config (zloop_t *loop, int timer_id, void *argument)
{
    tch_s_server_t *self = (tch_s_server_t *) argument;
    if (zconfig_has_changed (self->config)
    &&  zconfig_reload (&self->config) == 0) {
        s_server_config_service (self);
        self->server.config = self->config;
        zsys_notice ("reloaded configuration from %s",
            zconfig_filename (self->config));
    }
    return 0;
}

static void
s_satisfy_pedantic_compilers (void)
{
    engine_set_next_event (NULL, NULL_event);
    engine_set_exception (NULL, NULL_event);
    engine_set_wakeup_event (NULL, 0, NULL_event);
    engine_send_event (NULL, NULL_event);
    engine_broadcast_event (NULL, NULL, NULL_event);
    engine_handle_socket (NULL, 0, NULL);
    engine_set_monitor (NULL, 0, NULL);
    engine_set_log_prefix (NULL, NULL);
    engine_configure (NULL, NULL, NULL);
    engine_verbose (NULL);
}

/* Constructor for the sub (a.k.a. subscription) class */
static tch_svsub_t *
sub_new(tch_svclient_t *client, const char *path, zhash_t *cache)
{
    tch_svsub_t *self = (tch_svsub_t *) zmalloc (sizeof (tch_svsub_t));
    self->client = client;
    self->path = strdup (path);
    self->cache = zhash_dup (cache);

    //  Cached filenames may be local, in which case prefix them with
    //  the subscription path so we can do a consistent match.

    tch_svsub_t *cache_item = (tch_svsub_t *) zhash_first (self->cache);
    while (cache_item) {
        char *key = (char *) zhash_cursor (self->cache);
        if (*key != '/') {
            size_t new_key_len = strlen (self->path) + strlen (key) + 2;
            char *new_key = (char *) calloc (new_key_len, sizeof (char));
            snprintf (new_key, new_key_len, "%s/%s", self->path, key);
            zsys_debug ("sub_new: new_key=%s", new_key);
            zhash_rename (self->cache, key, new_key);
            free (new_key);
        }
        cache_item = (tch_svsub_t *) zhash_next (self->cache);
    }
    return self;
}

//  This is the server actor, which polls its two sockets and processes
//  incoming messages
void
fmq_server (zsock_t *pipe, void *args)
{
    //  Initialize
    tch_s_server_t *self = s_server_new (pipe);
    assert (self);
    zsock_signal (pipe, 0);
    //  Actor argument may be a string used for logging
    self->log_prefix = args? (char *) args: "";
    //self->verbose = true;

    //  Set-up server monitor to watch for config file changes
    engine_set_monitor ((tch_server_t *) self, 1000, s_watch_server_config);
    //  Set up handler for the two main sockets the server uses
    engine_handle_socket ((tch_server_t *) self, self->pipe, s_server_handle_pipe);
    engine_handle_socket ((tch_server_t *) self, self->router, s_server_handle_protocol);

    //  Run reactor until there's a termination signal
    zloop_start (self->loop);

    //  Reactor has ended
    s_server_destroy (&self);
}